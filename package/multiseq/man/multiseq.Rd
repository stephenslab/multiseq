% Generated by roxygen2 (4.0.1): do not edit by hand
\name{multiseq}
\alias{multiseq}
\title{Estimate underlying signal from count data \code{x} and optionally the effect of a covariate \code{g}.}
\usage{
multiseq(x, g = NULL, read.depth = NULL, reflect = FALSE,
  baseline = "inter", minobs = 1, pseudocounts = 0.5, all = FALSE,
  center = FALSE, repara = TRUE, forcebin = FALSE, lm.approx = TRUE,
  disp = c("add", "mult"), nullcheck = TRUE, pointmass = TRUE,
  prior = "nullbiased", gridmult = 2, mixsd = NULL, VB = FALSE,
  shape.eff = FALSE, cxx = TRUE, computelogLR = FALSE, maxlogLR = NULL)
}
\arguments{
\item{x:}{a matrix of nsig by n counts where n should be a power of 2 or a vector of size n (nsig will be set to 1).}

\item{read.depth:}{an nsig-vector containing the total number of reads for each sample (used to test for association with the total intensity). Defaults to NULL.}

\item{reflect:}{bool, if TRUE signal is reflected, if FALSE signal is not reflected. Defaults to TRUE if n is not power of 2. See \code{\link{reflect}} for details.}

\item{baseline:}{can be "inter" or "grp" or a number. Uses intercept g=0 as baseline ("inter") or the group with the smallest g as baseline ("grp") or specifies value of g that should be baseline (number). If center==FALSE and baseline=="inter", then baseline will be overwritten and automatically set to "grp"}

\item{g:}{an nsig-vector containing group indicators/covariate value for each sample}

\item{minobs:}{minimum number of obs required to be in each logistic model}

\item{pseudocounts:}{a number to be added to counts}

\item{all:}{bool, if TRUE pseudocounts are added to all entries, if FALSE pseudocounts are added only to cases when either number of successes or number of failures (but not both) is 0}

\item{center:}{bool, indicating whether to center g}

\item{repara:}{bool, indicating whether to reparameterize alpha and beta so that their likelihoods can be factorized.}

\item{forcebin:}{bool, if TRUE don't allow for overdipersion. Defaults to TRUE if nsig=1}

\item{lm.approx:}{bool, indicating whether a WLS alternative should be used}

\item{disp:}{"all" or "mult", indicates which type of overdispersion is assumed when lm.approx=TRUE}

\item{pointmass:}{bool, indicating whether or not to use point mass in vector of sigmas}

\item{prior:}{used in EM}

\item{gridmult:}{density of grid of sigma vector}

\item{nullcheck:}{bool, if TRUE check that any fitted model exceeds the "null" likelihood}

\item{mixsd:}{vector of sigma components to be specified for mixture model; defaults to NULL, in which case an automatic procedure is used}

\item{VB:}{bool, indicates whether to use a variational Bayes alternative to EM}

\item{shape.eff:}{bool, indicating whether to consider only shape effects}

\item{cxx:}{bool, indicating whether to use Rcode or c++ code (faster)}

\item{computelogLR:}{bool, indicating whether to compute logLR or not}

\item{maxlogLR:}{a positive number, default=NULL, if maxlogLR is provided as a positive number, the function returns this number as logLR when logLR is infinite.}
}
\value{
a list with elements "baseline.mean", "baseline.var", "effect.mean", "effect.var", "logLR", "logLR.each.scale", "finite.logLR"
}
\description{
This function takes a series of Poisson count signals \code{x}, with data on different samples in each row, and smooths all simultaneously using a multiscale Poisson model. Optionally, it estimates the "effect" of a covariate \code{g}. Parameters \code{minobs}, \code{pseudocounts}, \code{all}, \code{center}, \code{repara}, \code{forcebin}, \code{lm.approx}, and \code{disp} are passed to \code{\link{glm.approx}}. Parameters \code{pointmass}, \code{prior}, \code{gridmult}, \code{nullcheck}, \code{mixsd}, \code{VB} are passed to \pkg{ashr}.
}

